---
#See https://github.com/HTTPArchive/almanac.httparchive.org/wiki/Authors'-Guide#metadata-to-add-at-the-top-of-your-chapters
title: CSS
description: Розділ CSS Web Almanac 2020 розповідає про кольори, одиниці величин, селектори, розміщення елементів, анімацію, медіа запити і використання Sass.
authors: [LeaVerou, svgeesus, rachelandrew]
reviewers: [estelle, fantasai, j9t, mirisuzanne, catalinred, hankchizljaw]
analysts: [rviscomi, LeaVerou, dooman87]
editors: [bazzadp]
translators: [tymosh]
LeaVerou_bio: Lea <a href="https://designftw.mit.edu">викладає курс "HCI & web programming"</a> і <a href="https://mavo.io">вивчає як зробити веб-програмування простішим</a> у <a href="https://mit.edu">MIT</a>. Вона є <a href="https://www.amazon.com/CSS-Secrets-Lea-Verou/dp/1449372635?tag=leaverou-20">авторкою</a> технічних бестселлерів та досвідченою <a href="https://lea.verou.me/speaking">спікеркою</a>. У неї є жага до відкритих веб стандартів, також вона є довготривалою учасницею <a href="https://www.w3.org/Style/CSS/members.en.php3">CSS Working Group</a>. Lea започаткувала <a href="https://github.com/leaverou">кілька популярних проектів і веб-застосунків з відкритим кодом</a>, таких як <a href="https://prismjs.com">Prism</a> та <a href="https://github.com/leaverou/awesomplete">Awesomplete</a>. Вона веде твітер <a href="https://twitter.com/leaverou">@leaverou</a> і блог <a href="https://lea.verou.me">lea.verou.me</a>.
svgeesus_bio: Chris Lilley є технічним директором World Wide Web Consortium (W3C). Вважається "батьком SVG", також співавтором PNG, співредактором CSS2, очолював групу розробників <code>@font-face</code> і був співрозробником WOFF. Був у Technical Architecture Group. Chris і досі намагається отримати керування кольором у веб. Зараз працює над CSS levels 3/4/5, Web Audio та WOFF2.
rachelandrew_bio: Я є веб-розробницею, авторкою текстів, спікеркою. Співзасновницею <a href="https://grabaperch.com">Perch CMS</a> і <a href="https://noti.st">Notist</a>. Членкинею <a href="https://www.w3.org/wiki/CSSWG">CSS Working Group</a>. Головною редакторкою <a href="https://www.smashingmagazine.com/">Smashing Magazine</a>.
discuss: 2037
results: https://docs.google.com/spreadsheets/d/1sMWXWjMujqfAREYxNbG_t1fOJKYCA6ASLwtz4pBQVTw/
featured_quote: Веб більше не підліток — йому вже 30 і він поводиться відповідно. Йому більше до вподоби стабільність і простота в читанні, ніж нові забавки і складність, він воліє не відволікатися на раптові забаганки.
featured_stat_1: 72.58%
featured_stat_label_1: Відсоток значень <code>&lt;length&gt;</code>, в яких використані одиниці <code>px</code>.
featured_stat_2: 91.05%
featured_stat_label_2: Відсоток мобільних сторінок, які використовують селектори з будь-якими вендорними префіксами
featured_stat_3: <code>darken()</code>
featured_stat_label_3: Найпопулярніші функції SCSS
---

## Вступ

Каскадні таблиці стилів (Cascading Stylesheets, CSS) – це мова, яка використовується для створення візуальної структури, форматування і розмальовування веб-сторінок та інших медіа. Це одна з трьох головних мов для побудови веб-сайтів. Іншими двома є HTML, який використовується для структури, і JavaScript, який використовується для визначення поведінки.

У [минулорічному початковому Web Almanac](../2019/), ми переглянули [велику кількість CSS метрик](../2019/css), отриманих з допомогою 41 SQL-запиту до даних HTTP Archive, щоб оцінити стан технологій у 2019. Цього року ми занурилися набагато глибше, щоб отримати не тільки кількість сторінок з певним CSS правилом, але й інформацію, *як саме* воно було використане.

Загалом, ми побачили веб у двох різних видах, коли справа доходить до використання CSS. У наших дописах в блогах та інформаційних бульбашках Twitter ми загалом більше обговорюємо найновіше та найяскравіше, однак все ще існують мільйони сайтів, які використовують код минулого десятиліття. Такі речі, як [вендорні префікси з минулої ери](#vendor-prefixes), [приватні фільтри IE](#filters), а також [використання float для розміщення елементів](#layout) в усій красі свого [clearfix](#class-names). Але ми також побачили вражаюче використання багатьох нових можливостей. Навіть таких, які тільки отримали всебічну підтримку цього року, як, наприклад, [`min()` and `max()`](#feature-queries). Однак, це загалом зворотня кореляція між тим, наскільки позитивно щось сприймається і тим, як широко це використовується. Наприклад, передові можливості [Houdini](#houdini) практично не використовувалися.

Схожим чином на конференціях ми часто фокусуємося на складних, випрацюваних випадках використання, від яких вибухає мозок, і стрічках Twitter, які заповнені твітами типу "CSS вміє *таке*?!". Однак, виявляється, що у більшості випадків використання CSS на практиці досить просте. [CSS змінні загалом використовуються як константи](#complexity) і рідко посилаються на інші змінні. `calc()` [найчастіше використовується з двома CSS властивостями](#calculations), градієнти [загалом мають дві точки](#gradients) і таке інше.

Веб більше не підліток — йому вже 30 і він поводиться відповідно. Йому більше до вподоби стабільність і простота в читанні, ніж нові забавки і складність, він воліє не відволікатися на раптові забаганки.

## Методологія

[HTTP Archive](https://httparchive.org/) проходиться [мільйоном сторінок](https://httparchive.org/reports/state-of-the-web#numUrls) кожного місяця і пропускає їх через приватний інстанс [WebPageTest](https://webpagetest.org/), щоб зберегти ключову інформацію кожної сторінки. (Більше про це можна дізнатися на сторінці [Методологія](./methodology)).

Цього року ми вирішили запитати в ком'юніті, які метрики вивчати. Ми почали з [застосунку для пропонування метрик і голосування за них](https://projects.verou.me/mavoice/?repo=leaverou/css-almanac&labels=proposed%20stat). Було отримано стільки цікавих варіантів, що ми врешті-решт включили майже всі! Ми тільки виключили метрики для шрифтів, оскільки є окремий [розділ про шрифти](./fonts).

Щоб отримати дані для цього розділу, був використаний 121 SLQ-запит, в цілому понад 10 тисяч рядків SQL, включаючи 3 тисячі рядків JavaScript функцій всередині SQL. Що робить цей розділ найбільшим розділом в історії Web Almanac.

Багато інженерної роботи було зроблено, для того, щоб уможливити такий масштабний аналіз. Так само, як і минулого року, ми пропустили весь CSS код через [CSS парсер](https://github.com/reworkcss/css) і зберегли всі [абстрактні синтаксичні дерева](https://uk.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%BD%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) (АСД) для всіх таблиць стилів у збірці. Результатом цих маніпуляцій стали колосальні 10 ТБ даних. Цього року ми також розробили [бібліотеку хелперів](https://github.com/leaverou/rework-utils), які опрацьовують АСД, і [парсер селекторів](https://projects.verou.me/parsel). Обидва рішення було випущено окремими проєктами з відкритим кодом. Більшість метрик використовувала [JavaScript](https://github.com/LeaVerou/css-almanac/tree/master/js) для отримання даних з одного АСД та [SQL](https://github.com/HTTPArchive/almanac.httparchive.org/tree/main/sql/2020/01_CSS) для агрегації цих даних з усієї збірки. Цікавить, як виглядатиме твій власний CSS за нашими метриками? Ми зробили [онлайн майданчик](https://projects.verou.me/css-almanac/playground), на якому ти можеш випробувати їх на своїх сайтах.

Для деяких метрик огляду АСД CSS було недостатньо. Ми хотіли подивитися на [SCSS](https://sass-lang.com/), коли були доступні sourcemaps, оскільки він показує, чого потребують розробники від CSS, на що він ще не здатний, в той час як CSS показує, що використовують розробники з наявного. Для цього ми мали використати *кастомну метрику* - JavaScript код, який виконується у краулері, коли він відвідує вказану сторінку. Ми не могли використати відповідний SCSS парсер, оскільки це б сильно сповільнило краулер. Тому ми мали звернутися до [регулярних виразів](https://github.com/LeaVerou/css-almanac/blob/master/runtime/sass.js) (*жахіття!*). Не дивлячись на такий грубий підхід, ми отримали [чимало прозрінь](#sass)!

Кастомні метрики також були використані для частини [аналізу кастомних властивостей](#custom-properties). Хоча ми можемо отримати багато інформації про кастомні властивості з самих таблиць стилів, ми не здатні побудувати діаграму залежностей без можливості поглянути на дерево DOM для контексту, оскільки кастомні властивості успадковуються. Огляд зведеного стилю ноди DOM також дає нам інформацію про те, до якого типу елементу застосована кожна властивість і які з них [зареєстровані](https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty). Цю інформацію ми також не можемо отримати з таблиць стилів.

<p class="note">Ми проходили наші сторінки і в настільному, і в мобільному режимах, але для великої кількості даних обидва режими дали схожі результати, тому, якщо не зазначено інше, представлена статистика у цьому розділі посилається на набір мобільних сторінок.</p>

## Використання

Поки JavaScript перевершує CSS у своїй частині розміру сторінки, CSS безсумнівно збільшився в розмірах за останні роки, з середньою сторінкою настільного пристрою, яка завантажує 62 КБ CSS коду, і однією з 10 сторінок, яка завантажує більше, ніж 240 КБ CSS коду. Мобільні сторінки використовують трохи менше CSS коду вздовж всіх відсоткових значень, але лише на 4-7 КБ. Хоча це безумовно більше, ніж в попередні роки, все ще далеко від [колосального середнього розміру JavaScript у 444 KB і топових 10% з 1.2 МБ](./javascript#how-much-javascript-do-we-use).

{{ figure_markup(
  image="stylesheet-size.png",
  caption="Поширення розміру передачі таблиць стилів на одну сторінку.",
  description="Гістограма показує поширення розміру передачі таблиць стилів на одну сторінку, яке включає компресію, коли це можливо. Сторінки настільних пристроїв схильний мати трохи більше байтів таблиць стилів на одну сторінку до близько 10 КБ. Відсотки 10, 25, 50, 75 та 90 для мобільних сторінок такі: 5, 22, 56, 122 та 234 КБ.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=762340058&format=interactive",
  sheets_gid="314594173",
  sql_file="stylesheet_kbytes.sql"
) }}

Було б резонно припустити, що багато цього CSS згенеровано препроцесорами або іншими інструментами для збірки, однак лише 15% включали sourcemaps. Незрозуміло, чи це більше говорить про прийняття sourcemap чи про використання інструментів для збірки. Серед цього переважна більшість (45%) прийшла з інших CSS файлів, показуючи процеси збірки, яким піддаються CSS файли, такі як мініфікація, використання <a hreflang="en" href="https://autoprefixer.github.io/">autoprefixer</a>, і/або <a hreflang="en" href="https://postcss.org/">PostCSS</a>. <a hreflang="en" href="https://sass-lang.com/">Sass</a> був більш популярним, ніж <a hreflang="en" href="https://lesscss.org/">Less</a> (34% від таблиць стилів з sourcemaps проти 21%), з SCSS як більш популярним діалектом (33% файлів .scss проти 1% .sass).

Всі ці кілобайти коду зазвичай розділені між кількома файлами та елементами `<style>`. Лише близько 7% сторінок тримають весь CSS код в одному окремому файлі, як нас часто вчать робити. Фактично, середня сторінка має 3 `<style>` елементи та 6 окремих таблиць стилів, серед них 10% мають в собі 14 `<style>` елементів та більш ніж 20 окремих файлів CSS! І поки це відносно прийнятно для настільних комп'ютерів, це справді вбиває [продуктивність](./performance) на мобільних пристроях, де час затримки є важливішим, ніж швидкість завантаження.

{{ figure_markup(
  caption="Найбільша кількість файлів стилів, завантажених однією сторінкою.",
  content="1,379",
  classes="big-number",
  sheets_gid="1111507751",
  sql_file="stylesheet_count.sql"
) }}

Важко повірити, але максимальна кількість файлів стилів на сторінку це 26 777 `<style>` елементів і 1 379 окремих! Я б точно хотіла обійти таку сторінку десятою дорогою!

{{ figure_markup(
  image="stylesheet-count.png",
  caption="Поширення кількості файлів стилів на сторінку.",
  description="Гістограма показує поширення файлів стилів на сторінку. Настільні та мобільні пристрої майже однакові за поширенням. 10, 25, 50, 75 та 90-ий проценти для мобільних пристроїв наступні: 1, 3, 6, 12 та 21 файл стилів на сторінку.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=163217622&format=interactive",
  sheets_gid="1111507751",
  sql_file="stylesheet_count.sql"
) }}

Іншим способом визначити розмір є кількість правил. Середня сторінка включає сумарно 448 правил та 5 454 визначень. Що цікаво, 10% сторінок містять мінімальну кількість CSS: менше ніж 13 правил! Попри те, що мобільні пристрої мають трохи менші файлі стилів, вони також містять трохи більше правил, показуючи менші правила в цілому (що має тенденцію траплятися з media запитами).

{{ figure_markup(
  image="rules.png",
  caption="Поширення сумарної кількості стильових правил на сторінку.",
  description="Гістограма показує поширення стильових правил на сторінку. Мобільні пристрої зазвичай мають трохи більше правил, ніж настільні пристрої. 10, 25, 50, 75 та 90-ий проценти для мобільних пристроїв наступні: 13, 140, 479, 1 074 та 1 831 правило на сторінку.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=1918103300&format=interactive",
  sheets_gid="42376523",
  sql_file="selectors.sql"
) }}

## Селектори та каскад

CSS пропонує кілька варіантів застосування стилів до сторінки: від класів, ідентифікаторів та з використанням надважливого каскаду для уникнення повторюваних стилів. То як розробники застосовують стилі до своїх сторінок?

### Назви класів

Для чого розробники використовують назви класів сьогодні? Щоб відповісти на це питання, ми поглянули на найпопулярніші назви класів. Список очолювали класи <a hreflang="en" href="https://fontawesome.com/">Font Awesome</a>, з яких 192 зі 198 були `fa` або `fa-*`! Єдиним, про що початкове дослідження могло нам сказати, було те, що Font Awesome надзвичайно популярний і використовується майже третиною сайтів!

Однак як тільки ми прибрали класи `fa-*` та `wp-*` (які йшли з <a hreflang="en" href="https://wordpress.com/">WordPress</a>, іншого надзвичайно популярного програмного рішення), ми отримали більш значущі результати. За вийнятком цих, класи, що описують стани, здаються найбільш популярними. Клас `.active` з'являється майже на половині класів, а `.selected` та `.disabled` практично не відстають.

Лише декілька з найпоширеніших класів були презентаційними, і більшість з них була або орієнтована на вирівнювання (`pull-right` і `pull-left` зі старішого <a hreflang="en" href="https://getbootstrap.com/">Bootstrap</a>, `alignright`, `alignleft` etc.) або `clearfix`, який досі використовується на 22% сайтів, попри те, що floats, як метод розміщення, витіснилися більш сучасними модулями Grid та Flexbox.

{{ figure_markup(
  image="popular-class-names.png",
  caption="Найпопулярніші класи за відсотком сторінок.",
  description="Гістограма показує 14 найпопулярніших назв класів для настільних та мобільних сторінок. Клас `active` знайдений на 40% сторінок. Решта класів зустрічається на 20-30% сторінок і є в порядку спадання наступною: `fa`, `fa-*;`, `pull-right`, `pull-left`, `selected`, `disabled`, `clearfix`, `button`, `title`, `wp-*;`, `btn`, `container` та `sr-only`.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=1187401149&format=interactive",
  sheets_gid="863628849",
  sql_file="top_selector_classes_wp_fa_prefixes.sql"
) }}

### Ідентифікатори

Не дивлячись на те, що ідентифікатори не користуються популярністю у деяких спільнотах через їх високу специфічність, більшість веб-сайтів їх досі використовує, хоч і досить скупо. Менше половини сторінок використовували більше одного ID з будь-якими селекторами (мали максимальну специфічність (1,х,у) або менше) і майже всі мали серединну специфічність, що не включала ID (0,x,y). Дивися <a hreflang="en" href="https://www.w3.org/TR/selectors/#specificity-rules">специфікацію селекторів</a> для більш детальної інформації про розрахунок специфічності та цього (a,b,c) запису.

Але для чого ці ідентифікатори використовувалися? Виявилося, що найпопулярнішими є структурні ID: “#content”, “#footer”, “#header”, “#main”, не дивлячись на наявні [відповідні HTML елементи](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Document_and_website_structure#HTML_layout_elements_in_more_detail), які могли б бути використані в якості селекторів, покращуючи при цьому семантичну розмітку.

{{ figure_markup(
  image="popular-ids.png",
  caption="Найпопулярніші ідентифікатори за відсотками сторінок.",
  description="Гістограма показує 10 найпопулярніших ідентифікаторів для настільних і мобільних сторінок. Найпопулярнішим ID є `content` з 14% сторінок. ID `footer` і `header` мають трохи менше поширення. Ідентифікатори `logo`, `main`, `respond`, `comments`, `fancybox-loading`, `wrapper` і `submit` мають 5-10% використання на сторінках. Єдиною помітною різницею між настільними й мобільними сторінками є ID `comments`, який використовується на близько 8% мобільних сторінок і лише на 5% настільних.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=141873739&format=interactive",
  sheets_gid="734822190",
  sql_file="top_selector_ids.sql"
) }}

Ідентифікатори також можуть бути використані для навмисного зниження або збільшення специфічності. <a hreflang="en" href="https://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/">Хак для запису селектора ID як селектора атрибута</a> (`[id="foo"]` замість `#foo`, щоб знизити специфічність) зустрічався на диво рідко і лише 0,3% сторінок використовували його як мінімум один раз. Інший хак, пов’язаний зі специфічністю ID, — використання заперечення + селектора нащадка, наприклад, `:not(#nonexistent) .foo` замість `.foo`, щоб збільшити специфічність, — був також доволі рідкісним і з’являвся лише на 0,1% сторінок.

### `!important` {important}

Натомість, старий, грубий `!important` і досі використовується, не дивлячись на його <a hreflang="en" href="https://www.impressivewebs.com/everything-you-need-to-know-about-the-important-css-declaration/#post-475:~:text=Drawbacks,-to">добре відомі недоліки</a>. Серединна сторінка використовує `!important` у майже 2% декларацій , або в 1 з 50 випадків.

{{ figure_markup(
  caption="Мобільні сторінки, які використовують `!important` в кожній декларації!",
  content="2,138",
  classes="big-number",
  sheets_gid="1743048352",
  sql_file="meta_important_adoption.sql"
) }}

Деякі розробники буквально не можуть зупинитися: ми знайшли 2304 настільних і 2138 мобільних сторінок, які використовують `!important` у кожній декларації!

{{ figure_markup(
  image="important-properties.png",
  caption="Поширення відсотків властивостей `!important` на сторінку.",
  description="Гістограма показує поширення відсотку властивостей !important на сторінку. Настільні сторінки використовують !important на більшій кількості властивостей, ніж мобільні. 10, 25, 50, 75 та 90-ий відсотки для мобільних є наступними: 0, 1, 2, 4 та 7% властивостей з !important.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=768784205&format=interactive",
  sheets_gid="1743048352",
  sql_file="meta_important_adoption.sql"
) }}

Що розробники так сильно хочуть перебити? Ми поглянули на розподіл за властивостями і виявили, що близько 80% сторінок використовують `!important` з властивістю `display`. Поширеною стратегією є використання `display: none !important` для приховування контенту допоміжними класами, щоб перебити наявний CSS, що використовує `display` для визначення способу розміщення. Це побічний ефект того, що було потоком у CSS. Він поєднав три ортогональні характеристики в одну: внутрішній спосіб розміщення, поведінку потоку і статус видимості – всі контролюються єдиною властивістю `display`. Є спроби розділити ці значення у різні ключові слова `display`, що дає змогу коригувати їх окремо за допомогою кастомних властивостей. На жаль, <a hreflang="en" href="https://caniuse.com/mdn-css_properties_display_multi-keyword_values">підтримка браузерами фактично відсутня</a> на даний момент.

{{ figure_markup(
  image="important-top-properties.png",
  alt="Найпоширеніші властивості з !important за відсотком сторінок.",
  caption="Найпоширеніші властивості з !important за відсотком сторінок.",
  description="Гістограма показує 10 найпоширеніших властивостей з `!important`. Мобільні та настільні сторінки використовують цей метод зі схожою частотою. Властивість `display` використовується з `!important` найбільше — 79% мобільних сторінок. В порядку спадання, наступні властивості на 71-58% мобільних сторінках є такими: `color`, `width`, `height`, `background`, `padding`, `margin`, `border`, `background-color` і `float`.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=257343566&format=interactive",
  sheets_gid="1222608982",
  sql_file="meta_important_properties.sql"
) }}

### Специфічність та класи

Окрім використання `id` та `!important` у якомога меншій кількості, існує тенденція обходити специфічність в цілому, вкладаючи всі критерії відбору селектора в єдиний клас, Таким способом всі правила змушують мати однакову специфічність та перетворюють каскад на простішу систему “останній перемагає”. БЕМ є популярною методологією такого типу, хоча і не єдиною. Хоча важко оцінити, скільки сайтів використовують тільки БЕМ-подібні методології через те, що їх наслідування у кожному правилі є досить рідкісним явищем (навіть <a hreflang="en" href="https://en.bem.info/">сайт БЕМу</a> використовує кілька класів  у багатьох селекторах), близько 10% сторінок мають медіанну специфічність (0,1,0), що показує в цілому на слідування БЕМ-подібним методологіям.  На протилежному кінці від БЕМу, часто розробники використовують <a hreflang="en" href="https://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/#safely-increasing-specificity">дубльовані класи</a>, щоб підвищити специфічність і підштовхнути селектор вперед іншого (напр. `.foo.foo` замість `.foo`). Такий хак для специфічності насправді більш популярний, ніж БЕМ, і використовується на 14% мобільних веб-сайтів (9% настільних)! Це може вказувати на те, що більшість розробників насправді не хочуть позбутися каскаду в цілому, а лише воліють більше контролю над ним.

<figure markdown>
Відсоток | Настільні | Мобільні
-- | -- | --
10 | 0,1,0 | 0,1,0
25 | 0,2,0 | 0,1,2
50 | 0,2,0 | 0,2,0
75 | 0,2,0 | 0,2,0
90 | 0,3,0 | 0,3,0

  <figcaption>
    {{ figure_link(
      caption="Поширення медіанної специфічності на сторінку.",
      sheets_gid="1213836297",
      sql_file="specificity.sql"
    ) }}
  </figcaption>
</figure>

### Селектори атрибутів

Найпопулярнішим селектором атрибута наразі є `type`, який використовується на 46% сторінок, ймовірно для стилізації елементів `<input>` різних типів, наприклад, стилізація текстових полів вводу окремим чином від радіо кнопок, чекбоксів, слайдерів, полів завантаження файлів тощо.

{{ figure_markup(
  image="attribute-selectors.png",
  caption="Найпопулярніші селектори атрибутів за відсотком сторінок.",
  description="Гістограма показує найпопулярніші селектори атрибутів за відсотком сторінок. Використання мобільними та настільними сторінками є приблизно однаковим. Найпопулярнішим селектором атрибута наразі є `type`, який використовується на 46% мобільних сторінок. Наступним є селектор атрибута є `class` з використанням на 30% мобільних сторінок. Наступні селектори атрибутів використовуються у відсотках від 17 до 3% в порядку спадання: `disabled`, `dir`, `title`, `hidden`, `controls`, `data-type`, `data-align`, `href`, `poster`, `role`, `style`, `xmlns`, `aria-disabled`, `src`, `id`, `name`, `lang` та `multiple`.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=320159317&format=interactive",
  sheets_gid="1926527049",
  sql_file="top_selector_attributes.sql"
) }}

### Псевдокласи та псевдоелементи

Завжди з’являється багато інертності, коли ми змінюємо щось у веб-платформі після її тривалого використання. Як приклад, веб досі в більшості не прийняв, що псевдоелементи мають окремий від псевдокласів синтаксис, навіть не дивлячись на те, що ця зміна відбулася більше десятиліття тому. Всі псевдоелементи, які також доступні з синтаксисом псевдокласів для зворотної підтримки, є набагато поширенішими (у співвідношенні 2,5 до 5!) саме з синтаксисом псевдокласів.

{{ figure_markup(
  image="selector-pseudo-classes.png",
  alt="Використання застарілого синтаксису :pseudo-class до ::pseudo-elements у відсотках мобільних сторінок.",
  caption="Використання застарілого синтаксису `:pseudo-class` до `::pseudo-elements` у відсотках мобільних сторінок.",
  description="Гістограма показує відсоток сторінок, які використовують синтаксис псевдокласу (з одною двокрапкою) проти синтаксису псевдоелементів (дві двокрапки) до псевдоелементів. Псевдоелемент `before` використовується з синтаксисом псевдокласу на 71% мобільних сторінок і синтаксисом псевдоелементу на 33% мобільних сторінок. Псевдоелемент `after` — з синтаксисом класу та елементу на 68% і 30% мобільних сторінок, `first-letter` на 7% і 1%, а `first-line` на 1% та 0% мобільних сторінок.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=227968207&format=interactive",
  sheets_gid="2029589646",
  sql_file="top_selector_pseudo_classes.sql"
) }}

На даний момент найпопулярнішими псевдокласами є ті, які відповідають за дії користувача, з `:hover`, `:focus` та `:active` на вершині цього списку. Всі вони використовуються на двох третинах сторінок, вказуючи на те, що розробникам подобається зручність вказування декларативних взаємодій з інтерфейсом.

`:root` виглядає більш популярним, ніж це виправдовується його функцією, і використовується на одній третині сторінок. В контенті HTML він просто вибирає елемент `<html>`, тож чому розробники просто не використають `html`? Ймовірна відповідь може стосуватися загальних практик, що використовуються для визначення кастомних властивостей, [які також широко використовуються](#custom-properties), на псевдокласі `:root`. Інша відповідь може стосуватися специфічності: `:root` як псевдоклас має вищу специфічність, ніж `html`: (0, 1, 0) проти (0, 0, 1). Це поширений хак — підвищити специфічність селектора, додавши перед ним `:root`, наприклад, `:root .foo` має специфічність (0, 2, 0) у порівнянні з (0, 1, 0) для `.foo`. Нерідко це все, що потрібно для легкого “підштовхування” селектора перед іншим у гонці каскадності та уникнути такої довбні як `!important`. Щоб перевірити своє припущення, ми додатково виміряли саме це: скільки сторінок використовують `:root` перед селектором-нащадком? Результати підтвердили нашу гіпотезу: 29% сторінок використовують `:root` саме таким чином! Навіть більше, 14% настільних сторінок і 19% мобільних використовують `html` перед селектором-нащадком, ймовірно для того, щоб “підштовхнути” специфічність селектора навіть слабше. Популярність таких хаків очевидно вказує на потребу розробників у можливості більш тонко керувати специфічністю, ніж їм дозволяє `!important`. На щастя, це скоро стане можливим з [`:where()`](https://developer.mozilla.org/en-US/docs/Web/CSS/:where), що вже <a hreflang="en" href="https://caniuse.com/mdn-css_selectors_where">всебічно реалізований</a> (хоч і захований за прапорцем у Chrome наразі).

{{ figure_markup(
  image="popular-selector-pseudo-classes.png",
  caption="Найпопулярніші псевдокласи у відсотках сторінок.",
  description="Гістограма показує найпопулярніші псевдокласи у відсотках настільних та мобільних сторінок. Останні майже схожі, хоча мобільні сторінки мають трохи більший рівень прийняття. Найпопулярнішим псевдокласом є `hover`, який використовується на 84% сторінок. Наступні псевдокласи мають майже лінійний графік зменшення популярності від 71% до 12%: `before`, `after`, `focus`, `active`, `first-child`, `last-child`, `visited`, `not`, `root`, `nth-child`, `link`, `disabled`, `empty` та `nth-of-type`.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=1363774711&format=interactive",
  sheets_gid="2029589646",
  sql_file="top_selector_pseudo_classes.sql"
) }}

Коли справа стосується псевдоелементів, після звичних `::before` і `::after`, майже всі популярні псевдоелементи були розширеннями браузерів для стилізування елементів керування формами та іншими вбудованими елементами інтерфейсу, що вчергове вказує на потребу розробників у можливості більш тонкого керування стилізуванням вбудованих елементів інтерфейсу. Стилізування фокусних рамок, плейсхолдерів, пошукових полів вводу, спінерів, елемента виділення, смуг прокрутки, елементів керування медіа було особливо популярним.

{{ figure_markup(
  image="popular-selector-pseudo-elements.png",
  caption="Найпопулярніші псевдоелементи у відсотках сторінок.",
  description="Гістограма показує найпопулярніші псевдоелементи у відсотках настільних і мобільних сторінок. Останні майже схожі, хоча мобільні сторінки мають трохи більший рівень прийняття. Найпопулярнішим псевдоелементом є `before`, який використовується на 33% мобільних сторінок. Псевдоелемент `after` використовується на 30% мобільних сторінок. `-moz-focus-inner` — на 24% сторінок. Популярність спадає від 17% до 4% для наступних псевдоелементів: `-webkit-input-placeholder`, `-moz-placeholder`, `-webkit-search-decoration`, `-webkit-search-cancel-button`, `-webkit-inner-spin-button`, `-webkit-outer-spin-button`, `-webkit-scrollbar` (7%), `selection`, `-ms-clear`, `-moz-selection`, `-webkit-media-controls` та `-webkit-scrollbar-thumb`.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=1417577353&format=interactive",
  sheets_gid="1972610663",
  sql_file="top_selector_pseudo_elements.sql",
  width=600,
  height=500
) }}

------------------------------------

### Помилки у CSS

Як з будь-якою складною платформою, що розвивається, не все робиться правильно. Погляньмо на деякі помилки, які допускають розробники.

#### Синтаксичні помилки

Для отримання більшості метрик у цьому розділі, ми використовували CSS парсер <a hreflang="en" href="https://github.com/reworkcss/css">Rework</a>. Попри те, що він допомагає збільшити точність, це також означає, що ми можемо врахувати більше помилок, ніж браузер. Навіть якщо одне визначення у цілому файлі містить помилку, парсер зупиниться і файл буде виключено з аналізу. Але наскільки багато файлів містять такі синтаксичні помилки? Виявилося, що настільні сторінки навіть більше, ніж мобільні! Якщо точніше, близько 10% таблиць стилів, знайдених на настільних сторінках, містять принаймні одну непоправну синтаксичну помилку, в той час як для мобільних цей відсоток становить лише 2%. Відмітимо, що це істотно занижений поріг, оскільки не всі синтаксичні помилки зупиняють парсер. Наприклад, пропущена крапка з комою лише зробить наступне правило частиною значення (напр. `{property: "color", value: "red background: yellow"}`) і не зупинить парсер з помилкою.

#### Неіснуючі властивості

Ми також поглянули на найпоширеніші неіснуючі властивості, використавши список існуючих. Ми виключили властивості з префіксами з цієї частини аналізу та вручну вилучили приватні властивості без префіксів (напр. `behavior` від Internet Explorer, який дивним чином все ще використовується на 200 тис. веб-сайтів). Серед неіснуючих властивостей, що залишилися:

- 37% були спотвореними формами властивостей з префіксами (напр. `webkit-transition` або `-transition`).
- 43% були формами безпрефіксних властивостей, які існують тільки з префіксами (напр. `font-smoothing`, яка була знайдена на 384 тис. сайтів), можливо доданими для сумісності через неправильне припущення про існуючий стандарт, або через примарні очікування, що це стане стандартом.
- Помилка, що просочилася до популярної бібліотеки. Завдяки цьому аналізу, ми виявили, що властивість `white-wpace` була присутньою на 234 027 веб-сайтах. Це забагато сайтів для помилки, яка могла трапитися органічно, тому ми вирішили копнути глибше. [Виявилося](https://twitter.com/rick_viscomi/status/1326739379533000704), що це був віджет від Facebook! Цей баг вже виправили.
- Інша дивина: властивість `font-rendering` була знайдена на 2 575 сторінках. Однак, ми не знайшли підтверджень існування такої властивості з префіксом або без нього. Існує надзвичайно популярна нестандартизована властивість <a hreflang="en" href="https://medium.com/better-programming/improving-font-rendering-with-css-3383fc358cbc">`-webkit-font-smoothing`</a>, яка присутня на 3 млн веб-сайтів (приблизно 49% сторінок), але вона недостатньо схожа на `font-rendering`, щоб бути орфографічною помилкою. Існує [`text-rendering`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-rendering), яка використовується приблизно на 100 тис. сайтів, тож можливо, що 2,5 тис. розробників неправильно запам’ятали назву властивості та поєднали `font-smoothing` і `text-rendering`.

{{ figure_markup(
  image="most-popupular-unknown-properties.png",
  caption="Найпопулярніші неіснуючі властивості.",
  description="Гістограма показує `webkit-transition` на 15% настільних і 14% мобільних сторінок, `font-smoothing` — на 13% і 12% відповідно, `user-drag` — 12% мобільних, `white-wpace` — 10% мобільних, `tap-highlight-color` — на 10% і 10%, `webkit-box-shadow` — на 4% і 4%, `ms-transform` — на 2% і 2%, `-transition` — на 1% і 1%, `font-rendering` — на 0% і 0%, `webkit-border-radius` — на 2% настільних, і `moz-border-radius` — на 2% настільних сторінок.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=1166982997&format=interactive",
  sheets_gid="84286607",
  sql_file="meta_unknown_properties.sql",
  width="600",
  height="401"
) }}

#### Розгорнутий запис правил перед скороченим

Використання розгорнутого запису правил після скороченого — це хороший спосіб використати значення за замовчуванням і перевизначити кілька властивостей. Це особливо корисно із властивостями, які мають цілий список значень, де використання розгорнутого запису дозволяє уникнути багаторазових повторень цього значення. Використання ж розгорнутого запису правил перед скороченим є завжди помилковим, оскільки скорочений запис “переб’є” розгорнутий. Наприклад:

```css
background-color: rebeccapurple; /* розгорнутий запис */
background: linear-gradient(white, transparent); /* скорочений запис */
```

Це створить градієнт не від `white` до `rebeccapurple`, а від `white` до `transparent`. Колір заднього фону `rebeccapurple` буде перебитий скороченим записом `background`, який іде наступним і який повертає всі розгорнуті записи властивостей до початкових значень.

Існує дві причини, чому розробники роблять таку помилку: або нерозуміння принципів роботи скороченого запису і того, яким скороченим правилом перебивається розгорнуте, або просто залишки кодового мотлоху від переміщення визначень.

Тож наскільки поширеною є ця помилка? Звичайно, не надто поширеною у 6 мільйонах топових сайтів, правильно? Ні! Виявляється, це надзвичайно поширена помилка, яка зустрічається принаймні один раз на 54% сайтів!

Цей тип помилки найчастіше трапляється зі скороченим записом `background`: більше половини (55%) таких помилок включає написання розгорнутого запису `background-*` після `background`. В цьому випадку, це може і не бути помилкою зовсім, а хорошим прогресивним вдосконаленням: браузери, які не підтримують певну особливість (напр. лінійні градієнти), будуть використовувати попередні значення розгорнутого запису (в даному випадку, колір заднього фону). Ті ж браузери, які “розуміють” скорочений запис, перевизначать розгорнутий запис значення явно або неявно.

{{ figure_markup(
  image="most-popupular-shorthands-after-longhands.png",
  caption="Найпопулярніші скорочені записи правил після розгорнутих.",
  description="Гістограма показує `background` на 56.46% настільних і 55.17% мобільних сторінок, `margin` — на 12.51% і 12.18% відповідно, `font` — на 10.15% і 10.31%, `padding` — на 8.36% і 7.87%, `border-radius` — на 1.08% і 3.14%, `animation` — на 3.18% і 3.05%, `list-style` — на 2.09% і 2.00% та `transition` — на 1.09% і 0.98% сторінок.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=1389278729&format=interactive",
  sheets_gid="1143644053",
  sql_file="meta_longhand_first_properties.sql"
) }}

## Sass

В той час, як аналіз коду CSS показує нам, що розробники роблять, препроцесорний код може нам показати, що розробники хотіли б робити, але не можуть, що є цікавішим. Sass складається з двох синтаксисів: більш мінімалістичного Sass та SCSS, ближчого до CSS. Перший впадає у немилість і не дуже використовується зараз, тож ми тільки розглянемо другий. Ми використали CSS з sourcemaps для того, щоб вибрати та проаналізувати таблиці стилів SCSS у “дикій природі”. Ми вибрали SCSS, оскільки це найпопулярніший препроцесорний синтаксис відповідно до проаналізованих sourcemaps.

Ми вже певний час знаємо, що розробникам потрібні функції для модифікації кольорів, і працюємо над ними у <a hreflang="en" href="https://drafts.csswg.org/css-color-5/">CSS Color 5</a>. Проте аналіз викликів SCSS функцій дає нам справжні дані щодо необхідності функцій для модифікації кольорів і також показує, які типи модифікацій кольорів найбільш необхідні.

Загалом більше третини Sass функцій використовуються для модифікації кольорів чи добування компонентів кольорів. Насправді всі знайдені модифікації кольорів були скоріше примітивними. Половина призначалася для затемнення кольору. Фактично, `darken()` була найпопулярнішою функцією і використовувалася навіть більше, ніж звичайний `if()`! Виявилося, що звичною стратегією є визначити основні яскраві кольори та використовувати `darken()` для створення темніших варіацій. Функція, яка навпаки робить кольори світлішими, менш поширена. Лише 5% функцій були `lighten()`, не дивлячись на те, що ця функція була в цілому на 6-му місці за популярністю. Функції, які змінюють альфа-канал, були 4% від всіх функцій, а змішування кольорів становить 3,5%. Інші типи модифікацій кольорів, такі як регулювання відтінку, насиченості, червоного/зеленого/синього каналу або складніша `adjust-color()` використовувалися доволі рідко.

{{ figure_markup(
  image="most-popupular-sass-function-calls.png",
  caption="Найпопулярніші функції Sass.",
  description="Гістограма показує, що `(other)` використовується на 23% настільних сторінок і на 23% мобільних, `darken` - на 17% і 18% відповідно, `if` - на 14% і 14%, `map-keys` - 8% і 9%, `percentage` - 8% і 8%, `map-get` - 8% і 7%, `lighten` - 5% і 6%, `nth` - 5% і 5%, `mix` - 4% і 4%, `length` - 3% і 3%, `type-of` - 2% і 2%, і `(alpha adjustment)` на 2% настільних і на 2% мобільних сторінок.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=774248494&format=interactive",
  sheets_gid="170555219",
  sql_file="sass_function_calls.sql"
) }}

Визначення кастомних функцій — це те, про що <a hreflang="en" href="https://github.com/w3c/css-houdini-drafts/issues/857">дискутували роками у Houdini</a>, але вивчення таблиць стилів Sass показує нам, наскільки поширеним є цей підхід. Виявилося, що достатньо поширеним. Принаймні, половина вивчених SCSS містить кастомні функції, оскільки медіанний SCSS файл містить не одну, а дві кастомні функції.

Існують також <a hreflang="en" href="https://github.com/w3c/csswg-drafts/issues/5009">свіжі</a> <a hreflang="en" href="https://github.com/w3c/csswg-drafts/issues/5624">дискусії</a> у CSS WG щодо представлення обмежених форм умовних конструкцій, і Sass дає нам деякі дані щодо того, наскільки це потрібно. Майже дві третини SCSS файлів містять принаймні один `@if` блок, становлячи майже дві третини всіх виразів контролю потоку. Функція `if()` також використовується для умовних виразів всередині значень, що робить цю функцію другою найпоширенішою серед усіх (14%).

{{ figure_markup(
  image="usage-of-control-flow-statements-scss.png",
  caption="Використання виразів для контролю потоку в SCSS.",
  description="Гістограма показує, що `@if` використовується на 63% настільних і на 63% мобільних сторінок, `@for` - на 55% і 55% відповідно, `@each` - на 54% і 55%, і `@while` - на 2% і 2%.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=157473209&format=interactive",
  sheets_gid="498478750",
  sql_file="sass_control_flow_statements.sql"
) }}

Інша майбутня специфікація, над якою зараз працюють, це <a hreflang="en" href="https://drafts.csswg.org/css-nesting/">CSS Nesting</a>, яка дасть нам змогу вкладати правила всередину інших правил так, як ми можемо це робити у Sass та інших препроцесорах, використовуючи `&`. Настільки поширеним є вкладення у файлах SCSS? Як виявляється, дуже поширеним. Переважна більшість файлів SCSS містить принаймні один явно вкладений селектор, в той час як використання разом із псевдокласами (напр. `&:hover`) та класами (напр. `&.active`) становить третину всіх файлів. І це не враховуючи неявне вкладення, де наявність нащадку тільки припускається і символ `&` не є необхідним.

{{ figure_markup(
  image="usage-of-explicit-nesting-in-scss.png",
  caption="Використання явного вкладення у SCSS.",
  description="Гістограма показує використання `Total` на 85% настільних і 85% мобільних сторінок, `&:pseudo-class` - на 83% і 83% відповідно, `&.class` - 80% і 80%, `&::pseudo-element` - 66% і 66%, `& (by itself)` - 62% і 62%, `&[attr]` - 57% і 57%, `& >` - 24% і 23%, `& +` - 21% і 20%, `& descendant` - 16% і 15% та `&#id` - на 6% настільних і 6% мобільних сторінок.",
  chart_url="https://docs.google.com/spreadsheets/d/e/2PACX-1vRpe_HsNGpekn6YZV9k6QGmcZPxalqnDrL7DrDY-7X65RZEf_-aGfWuEvhk-yWV83ctIceE1bppCLpj/pubchart?oid=370242263&format=interactive",
  sheets_gid="1872903377",
  sql_file="sass_nesting.sql"
) }}

## Висновок

Хух! Яка кількість інформації! Сподіваємося, для вас вона була не менш цікавою, ніж для нас, і, можливо, ви навіть отримали свої власні прозріння щодо якихось даних.

Одним з таких прозрінь для нас було те, що популярні бібліотеки, такі як WordPress, Bootstrap та Font Awesome одними з перших впроваджують нові можливості, в той час як індивідуальні розробники є більш консервативними.

Іншим спостереженням є те, що старого коду у вебі більше, ніж нового. Веб на практиці охоплює великий проміжок від коду 20-літньої давності до наднових технологій, які працюють тільки в останніх версіях браузерів. Також це дослідження показало, що деякі потужні можливості часто залишаються незрозумілими та невикористаними, хоча і добре сумісними.

Дослідження також показало деякі способи, якими розробники хотіли б використовувати CSS, але не можуть, і також дало нам певне розуміння речей, які розробників заплутують. Деякі з цих даних будуть передані CSS WG для допомоги з подальшою еволюцією CSS, оскільки базовані на даних рішення є найкращими рішеннями.

Ми в захваті від того, який вплив може мати цей аналіз на майбутню розробку веб-сайтів, і з нетерпінням чекаємо побачити, як ці метрики зміняться з часом!
